---
title:     "Testing parallel in R"
date:      "October 2015"
output:    html_document
theme: flatly
highlight: flatly
---

```{r libs_and_global_options, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, results=FALSE}
library(knitr)
opts_chunk$set(results="hold", cache=FALSE) ## change to FALSE to re-eval whole doc
```

This note has two purposes:

- to test R's `parallel` package's performance on a basic multicore machine
- to test a wrapper function around `base::lapply` and `parallel::parLapply`

### 1. Definition of varLapply

My objective for `varLapply` is to be a no-hassle wrapper around `lapply` and `parLapply`, with a syntax similar to `lapply` and a unique boolean `use_parallel` argument that could be switched on or off algorithmically.

```{r}
varLapply <- function(X, FUN,               # same syntax as base::lapply
                      use_parallel = TRUE,  # use parLapply by default
                      number_of_nodes = detectCores()-1,  # keep 1 core free by default
                      ...) {
    if (!use_parallel) {
        lapply(X, FUN, ...)
    } else {
        require(parallel)
        tmp_cluster <- makeForkCluster(nnodes = max(number_of_nodes,1))
        clusterExport(cl = tmp_cluster, varlist = c(), envir = parent.frame())
        output <- parLapply(cl = tmp_cluster, X = X, fun = FUN, ...)
        stopCluster(tmp_cluster)
        return(output)
    }
}
```

The purpose of `clusterExport(... envir = parent.frame())` is to import all variables/functions/objects from `varLapply`'s parent. There are probably more subtle ways of doing this, but it has worked so far.

### 2. Test 1: isPrime

```{r}
library(plyr); library(dplyr); library(magrittr); library(ggplot2)
library(parallel)
library(numbers)  # for the isPrime function

prime_test <- function(N,   # the integers we test for primality
                       K,   # the maximum number of times each loop tests N
                       P) { # the number of times each test is repeated for averaging
    L <- length(N)
    S <- L*K*P*2
    tests <- data.frame(matrix(NA, nrow = S, ncol = 5))
    colnames(tests) <- c("n", "k", "p", "b", "time")
    i <- 1
    for (n in 1:L) {
        for (k in 1:K) {
            for (p in 1:P) {
                for (b in c(FALSE, TRUE)) {
                    tests[i,] <- c(N[n], k, p, b, 0.0)
                    i <- i+1
    }}}}
    # each row of tests corresponds to a test unit where we run
    # isPrime(n) k times using varLapply(..., use_parallel = b);
    # output of system.time (elapsed) is stored in the time column;
    # each case is repeated P times for averaging;
    # we sample test units in random order to reduce bias potential
    for (j in sample(1:S)) { 
        tests[j,"time"] <- system.time(varLapply(X = rep(tests[j,"n"], tests[j,"k"]),
                                                 FUN = isPrime,
                                                 use_parallel = tests[j,"b"])
                                       )[3]
        gc()
    }
    return(tests)
}
```

```{r}
prime_test(N = sapply(2:7, function(k) 2^(5*k)-1), K = 100, P = 3)
# large_test <- prime_test(N = sapply(2:7, function(k) 2*(5*k)-1), ########### ^^^^
#                          K = 200, 
#                          P = 3)
# save(large_test, file = "./test_save.Rdata")
```











---

Links that I have found useful:

- http://stackoverflow.com/questions/12019638/using-parallels-parlapply-unable-to-access-variables-within-parallel-code
- https://trinkerrstuff.wordpress.com/2012/08/19/parallelization-speed-up-functions-in-a-package/
- https://stat.ethz.ch/R-manual/R-devel/library/parallel/doc/parallel.pdf
- http://journal.r-project.org/archive/2012-2/RJournal_2012-2_Baaaath.pdf

Links that look useful and I still need to read:
- http://blog.dominodatalab.com/simple-parallelization/

---

R version:
```{r, echo=FALSE}
version[c("platform", "os", "version.string")]
```

```{r}
detectCores()
```

*Author: Alexandre Halm*  
*Edited with [RStudio](http://www.rstudio.com/products/RStudio/#Desk)*  